#!/usr/bin/env bash

# tunnel-manager.sh
# Purpose:
#   Manage multiple autossh port-forward tunnels on ServerA and expose them via HAProxy (TCP).
#
# What it does:
#   - Create new tunnel definitions (stored in /etc/ssh-tunnel-manager/*.conf)
#   - Generate/refresh systemd template units for autossh instances (one instance per local port)
#   - Maintain HAProxy TCP frontend/backend entries for each tunnel using a managed block
#   - Validate and reload HAProxy safely after changes
#
# Why HAProxy + SSH tunnels:
#   - One public TCP port per service, with HAProxy load-balancing across multiple autossh forwards
#   - Health checks and resilient failover (leastconn + tcp-check)
#   - Works without HAProxy "include"/"cfgdir" features (compatible with older HAProxy setups)
#
# HAProxy integration:
#   - Writes managed frontend/backend blocks directly into /etc/haproxy/haproxy.cfg
#     between:
#       # BEGIN MANAGED SSH TUNNELS (tunnel-manager.sh)
#       # END MANAGED SSH TUNNELS (tunnel-manager.sh)
#   - Do not edit the managed block manually (it is regenerated by this script)

set -euo pipefail

BASE_DIR="/etc/ssh-tunnel-manager"
HAPROXY_MAIN="/etc/haproxy/haproxy.cfg"

MARK_BEGIN="# BEGIN MANAGED SSH TUNNELS (tunnel-manager.sh)"
MARK_END="# END MANAGED SSH TUNNELS (tunnel-manager.sh)"

need_root() {
  if [[ "${EUID}" -ne 0 ]]; then
    echo "ERROR: Run as root." >&2
    exit 1
  fi
}

cmd_exists() { command -v "$1" >/dev/null 2>&1; }

ensure_deps() {
  local missing=0
  for c in autossh haproxy systemctl ss awk sed grep; do
    if ! cmd_exists "$c"; then
      echo "Missing command: $c"
      missing=1
    fi
  done
  if [[ $missing -eq 1 ]]; then
    echo "Install dependencies first:"
    echo "  apt update && apt install -y autossh haproxy iproute2"
    exit 1
  fi
}

ensure_dirs() { mkdir -p "${BASE_DIR}"; }

sanitize_name() {
  local name="$1"
  if [[ ! "$name" =~ ^[a-zA-Z0-9_-]+$ ]]; then
    echo "ERROR: Invalid name. Use only letters, numbers, '_' or '-'." >&2
    exit 1
  fi
}

conf_path() { echo "${BASE_DIR}/$1.conf"; }
unit_path() { echo "/etc/systemd/system/ssh-tunnel-$1@.service"; }

prompt() {
  local label="$1"
  local def="${2:-}"
  local var
  if [[ -n "$def" ]]; then
    read -r -p "$label [$def]: " var
    echo "${var:-$def}"
  else
    read -r -p "$label: " var
    echo "$var"
  fi
}

prompt_int() {
  local label="$1"
  local def="$2"
  local v
  while true; do
    v="$(prompt "$label" "$def")"
    if [[ "$v" =~ ^[0-9]+$ ]] && (( v > 0 && v < 65536 )); then
      echo "$v"; return
    fi
    echo "Please enter a valid number (1-65535)."
  done
}

prompt_ip() {
  local label="$1"
  local def="${2:-}"
  local v
  while true; do
    v="$(prompt "$label" "$def")"
    if [[ "$v" =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}$ ]]; then
      echo "$v"; return
    fi
    echo "Please enter a valid IPv4 address."
  done
}

list_tunnels() {
  shopt -s nullglob
  local files=("${BASE_DIR}"/*.conf)
  shopt -u nullglob
  if [[ ${#files[@]} -eq 0 ]]; then
    echo ""; return 0
  fi
  for f in "${files[@]}"; do
    basename "$f" .conf
  done
}

count_tunnels() {
  shopt -s nullglob
  local files=("${BASE_DIR}"/*.conf)
  shopt -u nullglob
  echo "${#files[@]}"
}

confirm_yes_no() {
  local q="$1"
  local ans
  while true; do
    read -r -p "${q} [y/n]: " ans
    case "$ans" in
      y|Y) return 0 ;;
      n|N) return 1 ;;
      *) echo "Please answer y or n." ;;
    esac
  done
}

stop_tunnel_with_optional_haproxy() {
  local name="$1"

  stop_instances "$name"

# Dependency warning: Because public ports are on HAProxy
  local total
  total="$(count_tunnels)"

  echo ""
  echo "Tunnel '${name}' stopped."
  echo ""

  if systemctl is-active --quiet haproxy; then
    if (( total > 1 )); then
      echo "WARNING:"
      echo "  HAProxy is shared across tunnels."
      echo "  If you stop HAProxy, ALL tunnels' PUBLIC ports will go down,"
      echo "  so other tunnels will also become unreachable from outside."
      echo ""
    fi

    if confirm_yes_no "Do you want to STOP HAProxy too?"; then
      systemctl stop haproxy >/dev/null 2>&1 || true
      echo "HAProxy stopped."
    else
      echo "HAProxy kept running."
    fi
  else
    echo "Note: HAProxy is already NOT active."
  fi
}

load_conf() {
  local name="$1"
  local fp
  fp="$(conf_path "$name")"
  if [[ ! -f "$fp" ]]; then
    echo "ERROR: Tunnel config not found: $fp" >&2
    exit 1
  fi
  # shellcheck disable=SC1090
  source "$fp"
}

is_port_listening() {
  local port="$1"
  ss -lnt 2>/dev/null | awk '{print $4}' | grep -qE "[:.]${port}$"
}

all_used_public_ports() {
  shopt -s nullglob
  local files=("${BASE_DIR}"/*.conf)
  shopt -u nullglob
  local p
  for f in "${files[@]}"; do
    p="$(grep -E '^PUBLIC_PORT=' "$f" | head -n1 | cut -d= -f2- | tr -d '"' || true)"
    [[ -n "$p" ]] && echo "$p"
  done
}

all_used_local_ports() {
  shopt -s nullglob
  local files=("${BASE_DIR}"/*.conf)
  shopt -u nullglob
  local p
  for f in "${files[@]}"; do
    p="$(grep -E '^LOCAL_PORTS=' "$f" | head -n1 | cut -d= -f2- | tr -d '"' || true)"
    [[ -n "$p" ]] && echo "$p"
  done
}

find_free_block() {
  local n="$1"
  local start_from="$2"
  local p i ok

  p="$start_from"
  while (( p < 65000 )); do
    ok=1
    for (( i=0; i<n; i++ )); do
      if is_port_listening "$((p+i))"; then ok=0; break; fi
      if all_used_local_ports | tr ' ' '\n' | grep -qx "$((p+i))"; then ok=0; break; fi
    done
    if (( ok == 1 )); then echo "$p"; return; fi
    p=$((p+n))
  done

  echo "ERROR: Could not find a free local port block." >&2
  exit 1
}

render_unit() {
  local name="$1"
  load_conf "$name"
  local up
  up="$(unit_path "$name")"

  cat > "$up" <<EOF
[Unit]
Description=SSH Tunnel ${name} instance %i (ServerA -> ${DEST_IP}:${REMOTE_PORT})
After=network-online.target
Wants=network-online.target

[Service]
User=root
Environment="AUTOSSH_GATETIME=0"
ExecStart=/usr/bin/autossh -M 0 -N -g \\
  -L 127.0.0.1:%i:${REMOTE_HOST}:${REMOTE_PORT} ${SSH_USER}@${DEST_IP} -p ${SSH_PORT} \\
  -o "ServerAliveInterval=${ALIVE_INTERVAL}" \\
  -o "ServerAliveCountMax=${ALIVE_COUNT}" \\
  -o "ExitOnForwardFailure=yes" \\
  -o "StrictHostKeyChecking=no" \\
  -o "Compression=no" \\
  -c chacha20-poly1305@openssh.com
Restart=always
RestartSec=3

[Install]
WantedBy=multi-user.target
EOF
}

stop_instances() {
  local name="$1"
  load_conf "$name"
  local p
  for p in ${LOCAL_PORTS}; do
    systemctl stop "ssh-tunnel-${name}@${p}" >/dev/null 2>&1 || true
  done
}

start_instances() {
  local name="$1"
  load_conf "$name"
  local p
  for p in ${LOCAL_PORTS}; do
    systemctl enable --now "ssh-tunnel-${name}@${p}" >/dev/null
  done
}

restart_instances() {
  local name="$1"
  load_conf "$name"
  local p
  for p in ${LOCAL_PORTS}; do
    systemctl restart "ssh-tunnel-${name}@${p}" >/dev/null 2>&1 || true
  done
}

enable_and_start_tunnel() {
  local name="$1"
  start_instances "$name"
  echo "OK: '${name}' enabled and started."
}

disable_and_stop_tunnel() {
  local name="$1"
  load_conf "$name"
  local p
  for p in ${LOCAL_PORTS}; do
    systemctl disable --now "ssh-tunnel-${name}@${p}" >/dev/null 2>&1 || true
  done
  echo "OK: '${name}' disabled and stopped."
}

restart_tunnel() {
  local name="$1"
  restart_instances "$name"
  echo "OK: '${name}' restarted."
}

status_one_tunnel() {
  local name="$1"
  load_conf "$name"

  echo ""
  echo "=== Tunnel status: ${NAME} ==="
  echo "  Public port : ${PUBLIC_PORT}"
  echo "  Dest        : ${DEST_IP}:${REMOTE_PORT}"
  echo "  Local ports : ${LOCAL_PORTS}"
  echo "  HAProxy     : $(systemctl is-active haproxy 2>/dev/null || echo "unknown")"

  local p
  for p in ${LOCAL_PORTS}; do
    if systemctl is-active --quiet "ssh-tunnel-${NAME}@${p}"; then
      echo "    - ssh-tunnel-${NAME}@${p}: active"
    else
      echo "    - ssh-tunnel-${NAME}@${p}: NOT active"
    fi
  done
}

ensure_markers_exist() {
  if [[ ! -f "$HAPROXY_MAIN" ]]; then
    echo "ERROR: HAProxy config not found at ${HAPROXY_MAIN}" >&2
    exit 1
  fi

  if ! grep -qF "$MARK_BEGIN" "$HAPROXY_MAIN"; then
    cat >> "$HAPROXY_MAIN" <<EOF

$MARK_BEGIN
$MARK_END
EOF
  fi
}

generate_managed_haproxy_block() {
  # Generates all frontends/backends for all tunnels from conf files.
  local tunnels
  IFS=$'\n' read -r -d '' -a tunnels < <(list_tunnels && printf '\0')

  echo "$MARK_BEGIN"
  echo "# Managed by tunnel-manager.sh"
  echo "# Do not edit this block manually."

  if [[ ${#tunnels[@]} -eq 0 || -z "${tunnels[0]:-}" ]]; then
    echo "# (No tunnels configured)"
    echo "$MARK_END"
    return
  fi

  local name idx p
  for name in "${tunnels[@]}"; do
    load_conf "$name"

    echo ""
    echo "frontend f_${NAME}"
    echo "  bind 0.0.0.0:${PUBLIC_PORT}"
    echo "  mode tcp"
    echo "  default_backend b_${NAME}"
    echo ""
    echo "backend b_${NAME}"
    echo "  mode tcp"
    echo "  balance leastconn"
    echo "  option tcp-check"

    idx=1
    for p in ${LOCAL_PORTS}; do
      echo "  server ${NAME}_${idx} 127.0.0.1:${p} check"
      idx=$((idx+1))
    done
  done

  echo ""
  echo "$MARK_END"
}

rewrite_haproxy_managed_block() {
  ensure_markers_exist

  local tmp
  tmp="$(mktemp)"

  # Remove existing managed block and replace it with a fresh generated block.
  awk -v b="$MARK_BEGIN" -v e="$MARK_END" '
    BEGIN{inblock=0}
    index($0,b){inblock=1; next}
    index($0,e){inblock=0; next}
    inblock==0{print}
  ' "$HAPROXY_MAIN" > "$tmp"

  # Append the new block at the end (keeps it simple and safe)
  generate_managed_haproxy_block >> "$tmp"

  mv "$tmp" "$HAPROXY_MAIN"
}

validate_haproxy() { haproxy -c -f "$HAPROXY_MAIN" >/dev/null; }

reload_services() {
  systemctl daemon-reload
  systemctl reload-or-restart haproxy >/dev/null
}

add_tunnel() {
  echo "=== Add tunnel ==="
  local name dest_ip remote_port public_port ssh_user ssh_port remote_host n alive_i alive_c

  name="$(prompt "Tunnel name (e.g. france_5051)")"
  sanitize_name "$name"

  local fp
  fp="$(conf_path "$name")"
  if [[ -f "$fp" ]]; then
    echo "ERROR: Tunnel already exists: $name" >&2
    exit 1
  fi

  dest_ip="$(prompt_ip "Destination server IP")"
  remote_port="$(prompt_int "Remote service port on destination (REMOTE_PORT)" "5051")"
  public_port="$(prompt_int "Public port on ServerA (PUBLIC_PORT)" "$remote_port")"

  # Prevent duplicate PUBLIC_PORT across tunnels (very common mistake)
  if all_used_public_ports | tr ' ' '\n' | grep -qx "$public_port"; then
    echo "ERROR: PUBLIC_PORT ${public_port} is already used by another tunnel." >&2
    echo "Choose another PUBLIC_PORT (e.g. ${public_port}1 or ${public_port}2)." >&2
    exit 1
  fi
  if is_port_listening "$public_port"; then
    echo "ERROR: PUBLIC_PORT ${public_port} is currently in use (listening)." >&2
    exit 1
  fi

  ssh_user="$(prompt "SSH user" "root")"
  ssh_port="$(prompt_int "SSH port" "22")"
  remote_host="$(prompt "Remote host (usually 127.0.0.1)" "127.0.0.1")"

  n="$(prompt_int "Number of parallel tunnels" "8")"
  alive_i="$(prompt_int "ServerAliveInterval seconds" "10")"
  alive_c="$(prompt_int "ServerAliveCountMax" "6")"

  local start
  start="$(find_free_block "$n" "6000")"

  local ports="" i
  for (( i=0; i<n; i++ )); do ports+="$((start+i)) "; done
  ports="${ports%% }"

  cat > "$fp" <<EOF
# Managed by tunnel-manager.sh
NAME="${name}"
DEST_IP="${dest_ip}"
SSH_USER="${ssh_user}"
SSH_PORT="${ssh_port}"
REMOTE_HOST="${remote_host}"
REMOTE_PORT="${remote_port}"
PUBLIC_PORT="${public_port}"
PARALLEL="${n}"
LOCAL_PORTS="${ports}"
ALIVE_INTERVAL="${alive_i}"
ALIVE_COUNT="${alive_c}"
EOF

  render_unit "$name"

  # Rebuild HAProxy managed block including this tunnel
  rewrite_haproxy_managed_block
  ensure_haproxy_global_defaults
  validate_haproxy
  reload_services
  start_instances "$name"

  echo "OK: Tunnel '${name}' added."
  echo "  Public port on ServerA: ${public_port}"
  echo "  Destination: ${dest_ip}:${remote_port}"
  echo "  Local tunnel ports: ${ports}"
}

edit_tunnel() {
  echo "=== Edit tunnel ==="
  local tunnels
  IFS=$'\n' read -r -d '' -a tunnels < <(list_tunnels && printf '\0')

  if [[ ${#tunnels[@]} -eq 0 || -z "${tunnels[0]:-}" ]]; then
    echo "No tunnels found in ${BASE_DIR}."
    return
  fi

  echo "Select a tunnel to edit:"
  local PS3="Enter choice: "
  local name
  select name in "${tunnels[@]}" "Cancel"; do
    if [[ "$name" == "Cancel" ]]; then return; fi
    if [[ -n "$name" ]]; then break; fi
    echo "Invalid choice."
  done

  load_conf "$name"
  echo ""
  echo "Current settings:"
  echo "  NAME        : ${NAME}"
  echo "  DEST_IP     : ${DEST_IP}"
  echo "  REMOTE_PORT : ${REMOTE_PORT}"
  echo "  PUBLIC_PORT : ${PUBLIC_PORT}"
  echo "  SSH_USER    : ${SSH_USER}"
  echo "  SSH_PORT    : ${SSH_PORT}"
  echo "  LOCAL_PORTS : ${LOCAL_PORTS}"
  echo ""

  local new_ip new_rport new_user new_sport
  new_ip="$(prompt_ip "New destination IP (DEST_IP)" "${DEST_IP}")"
  new_rport="$(prompt_int "New remote port (REMOTE_PORT)" "${REMOTE_PORT}")"
  new_user="$(prompt "New SSH user" "${SSH_USER}")"
  new_sport="$(prompt_int "New SSH port" "${SSH_PORT}")"

  local fp
  fp="$(conf_path "$name")"

  # Stop current instances before changing unit
  stop_instances "$name"

  cat > "$fp" <<EOF
# Managed by tunnel-manager.sh
NAME="${NAME}"
DEST_IP="${new_ip}"
SSH_USER="${new_user}"
SSH_PORT="${new_sport}"
REMOTE_HOST="${REMOTE_HOST}"
REMOTE_PORT="${new_rport}"
PUBLIC_PORT="${PUBLIC_PORT}"
PARALLEL="${PARALLEL}"
LOCAL_PORTS="${LOCAL_PORTS}"
ALIVE_INTERVAL="${ALIVE_INTERVAL}"
ALIVE_COUNT="${ALIVE_COUNT}"
EOF

  render_unit "$name"

  # Rebuild HAProxy managed block (ports might not change, but safe)
  rewrite_haproxy_managed_block
  ensure_haproxy_global_defaults
  validate_haproxy
  reload_services
  restart_instances "$name"

  echo "OK: Tunnel '${name}' updated and restarted."
}

ensure_haproxy_global_defaults() {
  if [[ ! -f "$HAPROXY_MAIN" ]]; then
    echo "ERROR: HAProxy config not found at ${HAPROXY_MAIN}" >&2
    exit 1
  fi

  # -----------------------------
  # 1) Ensure "global" has a log address
  # Fixes: "log format ignored ... no log address"
  # -----------------------------
  if grep -qE '^[[:space:]]*global[[:space:]]*$' "$HAPROXY_MAIN"; then
    if ! grep -qE '^[[:space:]]*log[[:space:]]+/dev/log' "$HAPROXY_MAIN"; then
      awk '
        BEGIN{in_global=0; added=0}
        /^[[:space:]]*global[[:space:]]*$/ {print; in_global=1; next}
        in_global==1 && added==0 {
          print "  log /dev/log local0"
          print "  log /dev/log local1 notice"
          added=1
        }
        in_global==1 && $0 ~ /^[^[:space:]]/ {in_global=0}
        {print}
      ' "$HAPROXY_MAIN" > "${HAPROXY_MAIN}.tmp" && mv "${HAPROXY_MAIN}.tmp" "$HAPROXY_MAIN"
    fi
  fi

  # -----------------------------
  # 2) Ensure "defaults" has required timeouts
  # Fixes: "missing timeouts for frontend/backend"
  # -----------------------------
  if grep -qE '^[[:space:]]*defaults[[:space:]]*$' "$HAPROXY_MAIN"; then
    local has_connect has_client has_server

    has_connect="$(
      awk '
        BEGIN{in_defaults=0}
        /^[[:space:]]*defaults[[:space:]]*$/ {in_defaults=1; next}
        in_defaults==1 && $0 ~ /^[^[:space:]]/ {in_defaults=0}
        in_defaults==1 && $0 ~ /^[[:space:]]*timeout[[:space:]]+connect/ {print "yes"; exit}
      ' "$HAPROXY_MAIN"
    )"

    has_client="$(
      awk '
        BEGIN{in_defaults=0}
        /^[[:space:]]*defaults[[:space:]]*$/ {in_defaults=1; next}
        in_defaults==1 && $0 ~ /^[^[:space:]]/ {in_defaults=0}
        in_defaults==1 && $0 ~ /^[[:space:]]*timeout[[:space:]]+client/ {print "yes"; exit}
      ' "$HAPROXY_MAIN"
    )"

    has_server="$(
      awk '
        BEGIN{in_defaults=0}
        /^[[:space:]]*defaults[[:space:]]*$/ {in_defaults=1; next}
        in_defaults==1 && $0 ~ /^[^[:space:]]/ {in_defaults=0}
        in_defaults==1 && $0 ~ /^[[:space:]]*timeout[[:space:]]+server/ {print "yes"; exit}
      ' "$HAPROXY_MAIN"
    )"

    # If any timeout is missing, add a safe TCP defaults block
    if [[ -z "$has_connect" || -z "$has_client" || -z "$has_server" ]]; then
      awk '
        BEGIN{in_defaults=0; inserted=0}
        /^[[:space:]]*defaults[[:space:]]*$/ {print; in_defaults=1; next}
        in_defaults==1 && inserted==0 {
          print "  log global"
          print "  mode tcp"
          print "  option tcplog"
          print "  timeout connect 5s"
          print "  timeout client  1h"
          print "  timeout server  1h"
          inserted=1
        }
        in_defaults==1 && $0 ~ /^[^[:space:]]/ {in_defaults=0}
        {print}
      ' "$HAPROXY_MAIN" > "${HAPROXY_MAIN}.tmp" && mv "${HAPROXY_MAIN}.tmp" "$HAPROXY_MAIN"
    fi
  fi
}

show_status() {
  echo "=== Status ==="
  local tunnels
  IFS=$'\n' read -r -d '' -a tunnels < <(list_tunnels && printf '\0')

  if [[ ${#tunnels[@]} -eq 0 || -z "${tunnels[0]:-}" ]]; then
    echo "No tunnels found."
    return
  fi

  local name p
  for name in "${tunnels[@]}"; do
    load_conf "$name"
    echo ""
    echo "Tunnel: ${NAME}"
    echo "  Public port : ${PUBLIC_PORT}"
    echo "  Dest        : ${DEST_IP}:${REMOTE_PORT}"
    echo "  Local ports : ${LOCAL_PORTS}"
    for p in ${LOCAL_PORTS}; do
      if systemctl is-active --quiet "ssh-tunnel-${NAME}@${p}"; then
        echo "    - ssh-tunnel-${NAME}@${p}: active"
      else
        echo "    - ssh-tunnel-${NAME}@${p}: NOT active"
      fi
    done
  done
}

manage_tunnel_menu() {
  echo "=== Manage tunnel ==="
  local tunnels
  IFS=$'\n' read -r -d '' -a tunnels < <(list_tunnels && printf '\0')

  if [[ ${#tunnels[@]} -eq 0 || -z "${tunnels[0]:-}" ]]; then
    echo "No tunnels found in ${BASE_DIR}."
    return
  fi

  echo "Select a tunnel to manage:"
  local PS3="Enter choice: "
  local name
  select name in "${tunnels[@]}" "Cancel"; do
    if [[ "$name" == "Cancel" ]]; then return; fi
    if [[ -n "$name" ]]; then break; fi
    echo "Invalid choice."
  done

  while true; do
    echo ""
    echo "----------------------------------------"
    echo " Manage: ${name}"
    echo "----------------------------------------"
    echo "1) Restart"
    echo "2) Disable and stop"
    echo "3) Enable and start"
    echo "4) Status"
    echo "5) Stop tunnel (ask about stopping HAProxy)"
    echo "6) Back"
    echo ""

    local c
    c="$(prompt "Choose an option" "4")"
    case "$c" in
      1) restart_tunnel "$name" ;;
      2) disable_and_stop_tunnel "$name" ;;
      3) enable_and_start_tunnel "$name" ;;
      4) status_one_tunnel "$name" ;;
      5) stop_tunnel_with_optional_haproxy "$name" ;;
      6) return ;;
      *) echo "Invalid option." ;;
    esac
  done
}

main_menu() {
  while true; do
    echo ""
    echo "========================================"
    echo " SSH Tunnel Manager (autossh + haproxy) "
    echo "========================================"
    echo "1) Add tunnel"
    echo "2) Edit tunnel"
    echo "3) Show status"
    echo "4) Manage tunnel (restart/enable/disable/status/stop)"
    echo "5) Exit"
    echo ""
    local choice
    choice="$(prompt "Choose an option" "1")"
    case "$choice" in
      1) add_tunnel ;;
      2) edit_tunnel ;;
      3) show_status ;;
      4) manage_tunnel_menu ;;
      5) exit 0 ;;
      *) echo "Invalid option." ;;
    esac
  done
}

need_root
ensure_deps
ensure_dirs
main_menu

